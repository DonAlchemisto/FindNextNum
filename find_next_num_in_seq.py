'''
mathologer's vid:
https://www.youtube.com/watch?v=4AuV93LOPcE

or vid by singing banana
https://www.youtube.com/watch?v=scQ51q_1nhw

Works if pattern is a polynomial
1st we take the diff until we reach constant diff
We can then apply Gregory-Newton's formula, or just add
diff -> Babbage machine


    TODO:
    - Use the falling power formula
    - Simplify the polynomial: we don't need to compute n_choose_k
      every time.
'''

import numpy as np
from collections import OrderedDict
from functools import partial

factorial = np.vectorize(np.math.factorial)
n_choose_k = lambda n, k: factorial(n) // (factorial(k) * factorial(n - k))
# Not the most efficient, replaced with the following

PHI = (1 + np.sqrt(5))/2


def binomial_coefficient(n: int, k: int) -> int:
    if k < 0 or k > n:
        return 0
    if k == 0 or k == n:
        return 1
    k = min(k, n - k) # Take advantage of symmetry
    ks = np.arange(k)
    cs = (n - ks) / (ks + 1)
    return np.prod(cs).astype(np.int64)


def find_next_num(seq):
    '''The Babbage difference engine way'''
    seq = np.array(seq)
    seq_len = seq.shape[0]
    
    if seq_len < 3:
        raise ValueError('Provided seq must be at least of length 3')

    diff_order = OrderedDict({0: seq})
    found_sol = False
    for diff in range(1, seq_len):
        d = np.diff(diff_order[diff - 1])
        if np.alen(d) < 2:
            break
        
        diff_order[diff] = d
        if np.alen(np.unique(d)) == 1:
            # all constants
            found_sol = True
            break

    if found_sol:
        order = diff
        result = 0
        for i in reversed(range(order + 1)):
            result += diff_order[i][-1]
        return result

    else:
        return


def get_nth_fibonacci(n):
    'Binet formula for the nth fibonacci num'
    r5 = np.sqrt(5)
    fn_n1 = ((1 + r5) / 2)**n
    fn_n2 = ((1 - r5) / 2)**n
    fn = (fn_n1 - fn_n2) / r5
    return np.round(fn, 0).astype(np.int64)


# The generalization of the above func
def get_nth_recursive_elem(n, *, seq):
    '''
    A generalization for any sequence produced by adding 2 consecutive elements
    to get the next element. Only works if the provided sequence is from the start.
    see: https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#Similar_integer_sequences
    '''
    r5 = np.sqrt(5)
    a = seq[1] * ((PHI**n) - (-PHI)**-n) / r5
    b = seq[0] * ((PHI**(n - 1)) - (-PHI)**(1-n)) / r5
    return int(round(a + b, 0))


def power_2(n):
    return pow(2, exp=n)



class PolySeq:
    '''
    Find what comes next in a sequence generated by a polynomial,
    or the special cases of 2^n, and sequences of the Fibonacci family,
    that are produced by adding the 2 previous elements.
    Can also jump directly to the nth element.
    '''
    def __init__(self, seq):
        '''
        attrs:
          - solvable: bool -> according to whether a constant difference was reached or not
          - recursive: bool -> similar to fibonacci and lucas numbers
            each type of sequence can have a generating function of its own
            
        methods:
          - get_nth_term:
              args: n [int] -> starting at ZERO
              returns: int

          - get_next_term:
            calls get_nth_term with the next term index
              returns: int
        '''
        # Establish the required difference
        self.seq = np.array(seq)
        seq_len = np.alen(self.seq)
        
        if seq_len < 3:
            raise ValueError('Provided seq must be at least of length 3')

        self.diff_order = {0: seq}
        self.solvable = False
        self.recursive = False
        for diff in range(1, seq_len):
            d = np.diff(self.diff_order[diff - 1])
            if np.alen(d) < 2:
                break
            
            self.diff_order[diff] = d
            if np.alen(np.unique(d)) == 1:
                # all constants
                self.solvable = True
                break

        if self.solvable:
            self.order = diff
            self._get_nth_term = self._construct_polynomial_formula()

        elif np.all(self.diff_order[1] == self.diff_order[0][:-1]):
            # It's a powers-of-2 seq [Special Case]
            self.solvable = True
            self.get_nth_term = np.frompyfunc(power_2, 1, 1)

        elif np.all(self.diff_order[1][:-1] + self.diff_order[2] == self.diff_order[0][:-2]):
            # it's a fibonacci sequence, OR DOES IT APPLY TO ALL THE FAMILY
            self.solvable = True
            self.recursive = True
            self.get_nth_term = partial(get_nth_recursive_elem, seq=self.seq)
            
            


    def _get_nth_term(self, n):
        '''Will only be called if self.solvable == False'''
        assert self.solvable == False
        raise ValueError('The provided sequence is unsolvable with this length at least')


    def get_nth_term(self, n):
        try:
            return self.seq[n]
        except IndexError:
            # Need to calculate it
            return self._get_nth_term(n)

    def get_next_term(self):
        return self.get_nth_term(len(self.seq))
        

    def _construct_polynomial_formula(self):
        def poly_formula(x, coeffs):
            xs = np.array([binomial_coefficient(x, i) for i in range(len(coeffs))])
            return np.sum(coeffs * xs).astype(np.int64)
            
        coeffs = np.fromiter((val[0] for val in self.diff_order.values()), dtype=np.int64)
        # Should simplify if they have a greatest common divisor

        # calculate exponents -> quick and easy way
        return partial(poly_formula, coeffs=coeffs)

    def print_diffs(self):
        start = ''
        for v in self.diff_order.values():
            print(start, v)
            start += '  '
        

def test():
    # Define some sequences to start with
    # pentagonal nums
    pent_nums = [0, 1, 5, 12, 22] # next should be 35

    # hexagonal nums
    hex_nums = [0, 1, 6, 15, 28] # next should be 45

    # First approach (Babbage engine)
    next_num = find_next_num(pent_nums)

    # Second approach (Newton's)
    solver = PolySeq(pent_nums)
    assert solver.get_nth_term(5) == 35

    solver = PolySeq(hex_nums)
    assert solver.get_nth_term(5) == 45

    
    seq = [1, 2, 4, 8, 16, 31, 57, 99, 163]
    solver = PolySeq(seq)
    assert solver.get_nth_term(len(seq)) == 256

    fibs = np.apply_along_axis(get_nth_fibonacci, axis=0, arr=np.arange(1, 10))
    solver = PolySeq(fibs)
    assert solver.get_nth_term(len(fibs)) == 55

    lucas_nums = [2, 1, 3, 4, 7, 11, 18, 29, 47, 76, 123, 199, 322]
    solver = PolySeq(lucas_nums)
    assert solver.get_nth_term(len(lucas_nums)) == 521
    

if __name__ == '__main__':
    test()
